<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>훈수 AI Agent (MVP)</title>
  <style>
    :root { --border:#e5e7eb; --bg:#fafafa; --text:#111827; --muted:#6b7280; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif; color:var(--text); background:#fff; }
    header { padding:12px 16px; border-bottom:1px solid var(--border); display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0; }
    header .small { color:var(--muted); font-size:12px; }
    .wrap { height: calc(100vh - 54px); display:grid; grid-template-columns: 1.2fr 0.8fr; }
    .left, .right { height:100%; }
    .left { border-right:1px solid var(--border); display:flex; flex-direction:column; }
    .toolbar { padding:10px 12px; display:flex; gap:8px; align-items:center; border-bottom:1px solid var(--border); background:var(--bg); flex-wrap:wrap; }
    button, input[type="text"] { font: inherit; }
    button { border:1px solid var(--border); background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button.warn { background:#fff7ed; border-color:#fed7aa; }
    button.active { outline:2px solid #111827; }
    .row { display:flex; gap:8px; align-items:center; }
    .grow { flex:1; }
    .problem { display:flex; gap:12px; padding:12px; border-bottom:1px solid var(--border); }
    .problem img { max-width:220px; max-height:140px; object-fit:contain; border:1px solid var(--border); border-radius:10px; background:#fff; }
    .problem .meta { flex:1; min-width: 200px; }
    .problem label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    .problem input[type="file"] { display:block; }
    .problem input[type="text"] { width:100%; padding:10px 12px; border:1px solid var(--border); border-radius:10px; }
    .canvasWrap { position:relative; flex:1; background:#fff; }
    canvas { width:100%; height:100%; display:block; touch-action:none; background:#fff; }
    .statusbar { padding:8px 12px; border-top:1px solid var(--border); background:var(--bg); display:flex; justify-content:space-between; font-size:12px; color:var(--muted); }
    .right { display:flex; flex-direction:column; }
    .chat { flex:1; overflow:auto; padding:12px; background:#fff; }
    .msg { max-width: 90%; padding:10px 12px; border:1px solid var(--border); border-radius:14px; margin:8px 0; white-space:pre-wrap; line-height:1.4; }
    .msg.user { margin-left:auto; background:#f9fafb; }
    .msg.ai { margin-right:auto; background:#fff; }
    .msg.system { margin-right:auto; background:#fefce8; border-color:#fde68a; }
    .composer { border-top:1px solid var(--border); padding:10px; display:flex; gap:8px; align-items:center; background:var(--bg); }
    .composer input { flex:1; padding:10px 12px; border:1px solid var(--border); border-radius:12px; }
    .pill { font-size:12px; padding:4px 8px; border:1px solid var(--border); border-radius:999px; background:#fff; color:var(--muted); }
  </style>
</head>
<body>
<header>
  <h1>훈수 AI Agent (웹 MVP)</h1>
  <div class="small">왼쪽 필기 · 오른쪽 채팅 · 정지/진전없음 자동 힌트</div>
  <div class="grow"></div>
  <span class="pill" id="penInfo">pointer: -</span>
  <span class="pill" id="idleInfo">idle: 0s</span>
</header>

<div class="wrap">
  <!-- LEFT -->
  <section class="left">
    <div class="toolbar">
      <div class="row">
        <button id="toolPen" class="active">펜</button>
        <button id="toolEraser">지우개</button>
        <button id="undoBtn">Undo</button>
        <button id="clearBtn" class="warn">Clear</button>
      </div>
      <div class="row">
        <span class="pill">펜 굵기</span>
        <input id="penWidth" type="range" min="2" max="14" value="4" />
        <span class="pill">지우개</span>
        <input id="eraserWidth" type="range" min="8" max="40" value="18" />
      </div>
      <div class="grow"></div>
      <span class="pill" id="agentInfo">agent: ready</span>
    </div>

    <div class="problem">
      <img id="problemPreview" alt="문제 이미지" style="display:none;" />
      <div class="meta">
        <label>1) 문제 사진 업로드</label>
        <input id="problemFile" type="file" accept="image/*" />
        <div style="height:10px;"></div>
        <label>2) 문제 한 줄 요약(선택)</label>
        <input id="problemText" type="text" placeholder="예: 미분값 이용해서 극값 구하는 문제" />
        <div style="height:10px;"></div>
        <div class="small">자동 힌트/채팅 요청 시 현재 풀이 캔버스 스냅샷도 함께 전송됨</div>
      </div>
    </div>

    <div class="canvasWrap">
      <canvas id="board"></canvas>
    </div>

    <div class="statusbar">
      <div id="statusLeft">상태: 준비</div>
      <div id="statusRight">strokes: <span id="strokeCount">0</span></div>
    </div>
  </section>

  <!-- RIGHT -->
  <section class="right">
    <div id="chat" class="chat"></div>
    <div class="composer">
      <input id="chatInput" type="text" placeholder='여기에 질문/상태를 입력 (예: "정말 모르겠다")' />
      <button id="sendBtn">전송</button>
    </div>
  </section>
</div>

<script>
/** =========================
 *  설정: n8n Webhook URL/키
 * ========================= */
const N8N_WEBHOOK_URL = "https://YOUR_N8N_DOMAIN/webhook/hint"; // TODO: n8n 프로덕션 URL로 교체
const API_KEY = "CHANGE_ME"; // TODO: n8n에서 검사할 키와 맞추기
const USE_MOCK = true; // n8n 붙이기 전엔 true 추천. 붙이면 false.

/** =========================
 *  Agent 정책(조절 가능)
 * ========================= */
const IDLE_THRESHOLD_SEC = 120;      // 정지 감지 기준
const IDLE_COOLDOWN_SEC  = 90;       // 정지 힌트 쿨다운
const PROGRESS_WINDOW_SEC = 60;      // 진전 없음 판단 윈도우
const PROGRESS_MIN_STROKES = 1;      // 윈도우 내 최소 stroke 수
const PROGRESS_COOLDOWN_SEC = 120;   // 진전 없음 힌트 쿨다운
const MAX_HINT_LEVEL = 3;

/** =========================
 *  상태
 * ========================= */
let tool = "pen"; // "pen" | "eraser"
let hintLevel = 1; // 힌트 단계
let chatHistory = []; // {role:"user"|"assistant"|"system", content:"..."}
let problemImageDataUrl = null;

let lastInputAt = Date.now();
let lastIdleHintAt = 0;
let lastNoProgressHintAt = 0;

let strokes = []; // undo용: 각 stroke = { tool, width, points:[{x,y,p}], ts }
let isDrawing = false;
let currentStroke = null;

const $ = (id) => document.getElementById(id);

/** =========================
 *  UI helpers
 * ========================= */
function addMessage(role, content) {
  const chat = $("chat");
  const div = document.createElement("div");
  div.className = `msg ${role}`;
  div.textContent = content;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;

  if (role === "user") chatHistory.push({ role: "user", content });
  if (role === "ai") chatHistory.push({ role: "assistant", content });
  if (role === "system") chatHistory.push({ role: "system", content });
}

function setStatus(text) { $("statusLeft").textContent = "상태: " + text; }
function setAgentInfo(text) { $("agentInfo").textContent = "agent: " + text; }

function setTool(next) {
  tool = next;
  $("toolPen").classList.toggle("active", tool === "pen");
  $("toolEraser").classList.toggle("active", tool === "eraser");
}

function markInput(pointerType="-") {
  lastInputAt = Date.now();
  $("penInfo").textContent = "pointer: " + pointerType;
}

/** =========================
 *  캔버스 초기화 / 리사이즈 (좌표 어긋남 방지 핵심)
 * ========================= */
const canvas = $("board");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  // 표시 크기가 0이면(숨김/레이아웃 중) 스킵
  if (rect.width === 0 || rect.height === 0) return;

  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  redrawAll();
}

window.addEventListener("resize", () => requestAnimationFrame(resizeCanvas));

// 레이아웃 변화(툴바/문제 영역 높이 변화 등)에도 자동 대응
const ro = new ResizeObserver(() => {
  requestAnimationFrame(resizeCanvas);
});
ro.observe(canvas);
ro.observe(document.querySelector(".canvasWrap"));
ro.observe(document.querySelector(".left"));

function redrawAll() {
  const rect = canvas.getBoundingClientRect();
  ctx.clearRect(0, 0, rect.width, rect.height);

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, rect.width, rect.height);

  for (const stroke of strokes) drawStroke(stroke);
  $("strokeCount").textContent = String(strokes.length);
}

function drawStroke(stroke) {
  const points = stroke.points;
  if (!points || points.length < 1) return;

  if (stroke.tool === "eraser") {
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "rgba(0,0,0,1)";
    ctx.lineWidth = stroke.width;
  } else {
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = stroke.width;
  }

  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i=1; i<points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.stroke();
  ctx.restore();
}

/** =========================
 *  Pointer events
 * ========================= */
function getPos(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

canvas.addEventListener("pointerdown", (e) => {
  canvas.setPointerCapture(e.pointerId);
  markInput(e.pointerType);

  isDrawing = true;
  const pos = getPos(e);
  const p = (typeof e.pressure === "number" ? e.pressure : 0.5);

  const width = (tool === "pen") ? Number($("penWidth").value) : Number($("eraserWidth").value);
  currentStroke = { tool, width, ts: Date.now(), points: [{ x: pos.x, y: pos.y, p }] };
  strokes.push(currentStroke);

  redrawAll();
});

canvas.addEventListener("pointermove", (e) => {
  if (!isDrawing) return;
  markInput(e.pointerType);

  const pos = getPos(e);
  const p = (typeof e.pressure === "number" ? e.pressure : 0.5);
  currentStroke.points.push({ x: pos.x, y: pos.y, p });

  redrawAll();
});

canvas.addEventListener("pointerup", () => {
  isDrawing = false;
  currentStroke = null;
  redrawAll();
});

canvas.addEventListener("pointercancel", () => {
  isDrawing = false;
  currentStroke = null;
});

/** =========================
 *  문제 이미지 업로드
 * ========================= */
$("problemFile").addEventListener("change", async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    problemImageDataUrl = reader.result;
    const img = $("problemPreview");
    img.src = problemImageDataUrl;
    img.style.display = "block";
    addMessage("system", "문제 이미지 업로드 완료. 이제 왼쪽에서 풀이를 시작하세요.");

    // 이미지 표시로 레이아웃이 바뀌므로 캔버스 리사이즈 보장
    requestAnimationFrame(resizeCanvas);
  };
  reader.readAsDataURL(file);
});

/** =========================
 *  Undo / Clear / Tool
 * ========================= */
$("toolPen").addEventListener("click", () => setTool("pen"));
$("toolEraser").addEventListener("click", () => setTool("eraser"));

$("undoBtn").addEventListener("click", () => {
  strokes.pop();
  redrawAll();
  markInput("undo");
});

$("clearBtn").addEventListener("click", () => {
  strokes = [];
  redrawAll();
  markInput("clear");
});

/** =========================
 *  캔버스 스냅샷(전송용) - 해상도 줄이기
 * ========================= */
function canvasToDataURLScaled(maxW = 900) {
  const r = canvas.getBoundingClientRect();
  const w = Math.floor(r.width);
  const h = Math.floor(r.height);
  if (w <= 0 || h <= 0) return null;

  if (w <= maxW) return canvas.toDataURL("image/png");

  const scale = maxW / w;
  const tw = Math.floor(w * scale);
  const th = Math.floor(h * scale);

  const tmp = document.createElement("canvas");
  tmp.width = tw;
  tmp.height = th;
  const tctx = tmp.getContext("2d");
  tctx.drawImage(canvas, 0, 0, tw, th);
  return tmp.toDataURL("image/png");
}

/** =========================
 *  n8n 호출
 * ========================= */
function detectModeFromText(text) {
  const t = (text || "").toLowerCase();
  const keywords = ["정말 모르겠다", "답", "정답", "솔루션", "답 좀", "모르겠"];
  return keywords.some(k => t.includes(k)) ? "solution" : "hint";
}

async function callN8n({ mode="hint", level=1, userText="" , signals={} } = {}) {
  const payload = {
    mode,                 // "hint" | "more_hint" | "solution"
    hint_level: level,
    user_text: userText,
    problem_text: $("problemText").value || "",
    problem_image: problemImageDataUrl,
    work_image: canvasToDataURLScaled(900),
    chat_history: chatHistory.slice(-20),
    signals: {
      idle_seconds: Math.floor((Date.now() - lastInputAt) / 1000),
      no_progress: !!signals.no_progress,
      trigger: signals.trigger || "auto"
    },
    client_ts: Date.now()
  };

  if (USE_MOCK) {
    await new Promise(r => setTimeout(r, 350));
    return {
      reply: (mode === "solution")
        ? "MOCK 솔루션: (예시) 먼저 식을 정리한 뒤, 핵심 정리를 적용하세요..."
        : (mode === "more_hint"
            ? `MOCK 더 힌트(level ${level}): (예시) ‘여기서 KCL을 어느 노드에 쓰면 좋을까요?’`
            : `MOCK 힌트(level ${level}): (예시) ‘변수 하나를 잡고 식을 세워보세요.’`),
      next_hint_level: (mode === "solution") ? level : Math.min(level + 1, MAX_HINT_LEVEL)
    };
  }

  const res = await fetch(N8N_WEBHOOK_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": API_KEY
    },
    body: JSON.stringify(payload)
  });

  if (!res.ok) {
    const txt = await res.text().catch(()=> "");
    throw new Error(`n8n webhook failed: ${res.status} ${txt}`);
  }
  return await res.json(); // { reply, next_hint_level }
}

/** =========================
 *  채팅 전송
 * ========================= */
async function handleSend(text) {
  const userText = (text || "").trim();
  if (!userText) return;

  addMessage("user", userText);

  const mode = detectModeFromText(userText);
  const reqMode = (mode === "solution") ? "solution" : "hint";
  setStatus("AI 응답 생성 중...");
  setAgentInfo("thinking");

  try {
    const data = await callN8n({
      mode: reqMode,
      level: hintLevel,
      userText,
      signals: { trigger: "chat" }
    });
    addMessage("ai", data.reply || "(응답 없음)");
    hintLevel = data.next_hint_level ?? hintLevel;
    setStatus("준비");
    setAgentInfo("ready");
  } catch (e) {
    addMessage("system", "요청 실패: " + e.message);
    setStatus("오류");
    setAgentInfo("error");
  }
}

$("sendBtn").addEventListener("click", () => {
  const v = $("chatInput").value;
  $("chatInput").value = "";
  handleSend(v);
});
$("chatInput").addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    const v = $("chatInput").value;
    $("chatInput").value = "";
    handleSend(v);
  }
});

/** =========================
 *  진전 없음 감지(간단 버전)
 * ========================= */
function strokesInWindow(sec) {
  const now = Date.now();
  const from = now - sec * 1000;
  return strokes.filter(s => (s.ts || 0) >= from);
}

/** =========================
 *  자동 힌트 트리거
 *  - idle >= 120s
 *  - no_progress (최근 60s에 stroke가 거의 없음)
 *  쿨다운 적용
 * ========================= */
async function autoHint({ reason="idle", no_progress=false } = {}) {
  setStatus("자동 힌트 생성 중...");
  setAgentInfo("thinking");

  // 자동 힌트는 "답" 금지. hint/more_hint만 사용
  const mode = (hintLevel >= 2) ? "more_hint" : "hint";

  try {
    const data = await callN8n({
      mode,
      level: hintLevel,
      userText: "",
      signals: { trigger: reason, no_progress }
    });
    addMessage("ai", data.reply || "(응답 없음)");
    hintLevel = data.next_hint_level ?? hintLevel;
    setStatus("준비");
    setAgentInfo("ready");
  } catch (e) {
    addMessage("system", "자동 힌트 실패: " + e.message);
    setStatus("오류");
    setAgentInfo("error");
  }
}

/** =========================
 *  타이머: idle / progress 체크
 * ========================= */
setInterval(async () => {
  const now = Date.now();
  const idleSec = Math.floor((now - lastInputAt) / 1000);
  $("idleInfo").textContent = `idle: ${idleSec}s`;

  // 1) IDLE 자동 힌트
  if (idleSec >= IDLE_THRESHOLD_SEC) {
    const since = Math.floor((now - lastIdleHintAt) / 1000);
    if (since >= IDLE_COOLDOWN_SEC) {
      lastIdleHintAt = now;
      addMessage("system", "정지 감지 → 자동 힌트 제공");
      await autoHint({ reason: "idle", no_progress: false });
    }
  }

  // 2) 진전 없음 감지 (idle이 아주 길지 않아도, 최근 창에서 stroke 거의 없으면)
  const recent = strokesInWindow(PROGRESS_WINDOW_SEC);
  const recentCount = recent.length;
  const noProgress = recentCount <= PROGRESS_MIN_STROKES;

  if (noProgress) {
    const since = Math.floor((now - lastNoProgressHintAt) / 1000);
    // 너무 잦게 뜨지 않도록 + idle 트리거와 충돌 방지
    if (since >= PROGRESS_COOLDOWN_SEC && idleSec < IDLE_THRESHOLD_SEC) {
      lastNoProgressHintAt = now;
      addMessage("system", "진전 없음 감지 → 자동 힌트 제공");
      await autoHint({ reason: "no_progress", no_progress: true });
    }
  }
}, 1000);

/** =========================
 *  초기화
 * ========================= */
function init() {
  addMessage("system", "시작: 문제 이미지를 업로드하고, 왼쪽에 풀이를 쓰세요. (n8n 연결 전에는 MOCK 응답)");
  setStatus("준비");
  setAgentInfo("ready");

  // 초기 레이아웃 확정 이후 리사이즈 보장
  requestAnimationFrame(resizeCanvas);
  window.addEventListener("load", () => requestAnimationFrame(resizeCanvas));
}
init();
</script>
</body>
</html>
